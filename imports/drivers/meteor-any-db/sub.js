// Generated by CoffeeScript 2.2.4
(function() {
  var DB_KEY, changeDoc, debug, deleteUndefined, fields2Obj, findDocIdIndex, parseDDPMsg, parseId, ref, ref1;

  ({DB_KEY} = AnyDb); // Spoofing a Mongo collection name to hack around DDP

  debug = (function() {});

  if ((ref = Meteor.settings.public) != null ? (ref1 = ref.log) != null ? ref1.sub : void 0 : void 0) {
    debug = console.log.bind(console, 'sub');
  }

  // find the index of a document with a given id within a collection
  findDocIdIndex = function(id, docs) {
    var i, j, ref2;
    for (i = j = 0, ref2 = docs.length; (0 <= ref2 ? j < ref2 : j > ref2); i = 0 <= ref2 ? ++j : --j) {
      if (docs[i]._id === id) {
        return i;
      }
    }
    return -1;
  };

  // mutably remove fields that are set to undefined
  deleteUndefined = function(doc) {
    var k, v;
    for (k in doc) {
      v = doc[k];
      if (U.isPlainObject(v)) {
        doc[k] = deleteUndefined(v);
      } else if (v === void 0) {
        delete doc[k];
      }
    }
  };

  // update the document based on the fields
  changeDoc = function(doc, fields) {
    deleteUndefined(U.extendDeep(doc, fields));
  };

  // subs[subId] = subObject
  AnyDb.subs = {};

  AnyDb.subscribe = function(name, query, onReady) {
    var dispatchChange, handle, lap, sub;
    sub = {name, query}; // name and query are useful here just for debugging
    sub.data = []; // subscriptions always return collections
    sub.dataIds = {}; // keep track of which id's belong to this subscription
    sub.ready = false; // don't fire onChange methods until the subscription is ready
    
    // onChange listeners
    sub.listeners = {};
    sub.onChange = function(f) {
      var id;
      id = Random.hexString(10);
      sub.listeners[id] = f;
      return {
        stop: function() {
          return delete sub.listeners[id];
        }
      };
    };
    dispatchChange = function() {
      var f, id, ref2, results;
      if (sub.ready) {
        debug('change', sub.subId, 'listeners', Object.keys(sub.listeners).length);
        ref2 = sub.listeners;
        results = [];
        for (id in ref2) {
          f = ref2[id];
          results.push(f(R.clone(sub.data)));
        }
        return results;
      }
    };
    // The following observer methods will be called as DDP messages come in
    // via Meteor.connection.registerStore
    sub.addedBefore = function(id, fields, before) {
      var doc, i;
      doc = fields;
      doc._id = id;
      sub.dataIds[id] = true;
      if (before === null) {
        sub.data = sub.data.concat(doc);
      } else {
        i = findDocIdIndex(before, sub.data);
        if (i < 0) {
          throw new Error(`Expected to find before id, ${before}`);
        }
        sub.data = R.clone(sub.data);
        sub.data.splice(i, 0, doc);
      }
      return dispatchChange();
    };
    sub.movedBefore = function(id, before) {
      var doc, fromIndex, toIndex;
      fromIndex = findDocIdIndex(id, sub.data);
      if (fromIndex < 0) {
        throw new Error(`Expected to find id: ${id}`);
      }
      sub.data = R.clone(sub.data);
      doc = sub.data[fromIndex];
      sub.data.splice(fromIndex, 1);
      if (before === null) {
        sub.data.push(doc);
      } else {
        toIndex = findDocIdIndex(before, sub.data);
        if (toIndex < 0) {
          throw new Error(`Expected to find before _id: ${before}`);
        }
        sub.data.splice(toIndex, 0, doc);
      }
      return dispatchChange();
    };
    sub.changed = function(id, fields) {
      var i;
      sub.data = R.clone(sub.data);
      i = findDocIdIndex(id, sub.data);
      if (i < 0) {
        throw new Error(`Expected to find id: ${id}`);
      }
      changeDoc(sub.data[i], fields);
      return dispatchChange();
    };
    sub.removed = function(id) {
      var i, oldDoc;
      i = findDocIdIndex(id, sub.data);
      if (i < 0) {
        throw new Error("Expected to find id");
      }
      [oldDoc] = sub.data.splice(i, 1);
      delete sub.dataIds[id];
      return dispatchChange();
    };
    lap = U.stopwatch();
    debug('start', name);
    // make sure reactive computations dont fuck this up, especially
    // on hot reloads.
    handle = Tracker.nonreactive(function() {
      return Meteor.subscribe(name, query, {
        onReady: function() {
          debug('ready', name, sub.subId, lap(), 's');
          sub.ready = true;
          dispatchChange();
          return typeof onReady === "function" ? onReady(sub) : void 0;
        },
        onStop: function(e) {
          debug('stopped', name, sub.subId);
          if (e) {
            throw e;
          }
        }
      });
    });
    sub.subId = handle.subscriptionId;
    sub.stop = function() {
      debug('stop', name, sub.subId);
      sub.listeners = {};
      handle.stop();
      sub.data = [];
      sub.dataIds = {};
      // unregister the subscription
      return delete AnyDb.subs[sub.subId];
    };
    sub.reset = function() {
      debug('reset', name, sub.subId);
      sub.data = [];
      return sub.dataIds = {};
    };
    // dispatchChange()s

    // register the subscription
    AnyDb.subs[sub.subId] = sub;
    return sub;
  };

  // Find a certain document by id, where ever it may be in any subscription.
  AnyDb.findDoc = function(id) {
    var i, ref2, sub, subId;
    ref2 = AnyDb.subs;
    for (subId in ref2) {
      sub = ref2[subId];
      if (sub.dataIds[id]) {
        i = findDocIdIndex(id, sub.data);
        return R.clone(sub.data[i]);
      }
    }
    return void 0;
  };

  // unflatten DDP fields into a deep object
  fields2Obj = function(fields = {}) {
    var dest, key, keys, obj, prevObj, tmp, value;
    fields = R.clone(fields);
    dest = {};
    for (key in fields) {
      value = fields[key];
      keys = key.split('.').reverse();
      if (keys.length === 1) {
        dest[key] = value;
      } else {
        obj = {};
        prevObj = obj;
        while (keys.length > 1) {
          tmp = {};
          prevObj[keys.pop()] = tmp;
          prevObj = tmp;
        }
        prevObj[keys.pop()] = value;
        U.extendDeep(dest, obj);
      }
    }
    return dest;
  };

  // some weird stuff going on with DDP
  parseId = function(id) {
    if (id === "") {
      return id;
    } else if (id === '-') {
      return void 0;
    } else if (id.substr(0, 1) === '-') {
      return id.substr(1);
    } else if (id.substr(0, 1) === '~') {
      // numbered id's should remain strings!
      return JSON.parse(id.substr(1)).toString();
    } else {
      return id;
    }
  };

  // parse the subscription, position, cleared, fields, etc.
  parseDDPMsg = function(msg) {
    var before, cleared, fields, id, positions, subId, subObj, value;
    id = parseId(msg.id);
    msg.fields = fields2Obj(msg.fields);
    positions = {};
    cleared = {};
    subObj = msg.fields[DB_KEY];
    if (subObj) {
      for (subId in subObj) {
        value = subObj[subId];
        if (value === void 0) {
          cleared[subId] = true;
        } else {
          before = value.split('.')[1];
          if (before === "null") {
            before = null;
          }
          positions[subId] = before;
        }
      }
    }
    fields = R.clone(msg.fields);
    delete fields[DB_KEY];
    return {id, fields, positions, cleared};
  };

  Meteor.connection.registerStore(DB_KEY, {
    beginUpdate: function(batchSize, reset) {
      var ref2, results, sub, subId;
      if (reset) {
        ref2 = AnyDb.subs;
        results = [];
        for (subId in ref2) {
          sub = ref2[subId];
          results.push(sub.reset());
        }
        return results;
      }
    },
    update: function(msg) {
      var before, cleared, doc, fields, id, lookup, positions, ref2, ref3, sub, subId, value;
      ({id, fields, positions, cleared} = parseDDPMsg(msg));
      if (msg.msg === 'added') {
        for (subId in positions) {
          before = positions[subId];
          sub = AnyDb.subs[subId];
          sub.addedBefore(id, R.clone(fields), before);
        }
        return;
      }
      if (msg.msg === 'removed') {
        ref2 = AnyDb.subs;
        for (subId in ref2) {
          sub = ref2[subId];
          if (sub.dataIds[id]) {
            sub.removed(id);
          }
        }
        return;
      }
      if (msg.msg === 'changed') {
// remove cleared subscriptions which come in as a subId
// position set to undefined
        for (subId in cleared) {
          value = cleared[subId];
          sub = AnyDb.subs[subId];
          // the subscription cleans itself up when it stops so it may
          // not be found
          if (sub != null) {
            sub.removed(id);
          }
        }
        lookup = R.memoize(AnyDb.findDoc);
        for (subId in positions) {
          before = positions[subId];
          sub = AnyDb.subs[subId];
          // sub could be null apparently if you logout and back in really quickly
          if (!sub) {
            return;
          }
          if (sub.dataIds[id]) {
            sub.movedBefore(id, before);
          } else {
            doc = lookup(id);
            sub.addedBefore(id, R.omit(['_id'], doc), before);
          }
        }
        // the basic field changes
        if (Object.keys(fields).length > 0) {
          ref3 = AnyDb.subs;
          for (subId in ref3) {
            sub = ref3[subId];
            if (sub.dataIds[id]) {
              sub.changed(id, R.clone(fields));
            }
          }
        }
        return;
      }
      throw new Error("I don't know how to deal with this message");
    }
  });

}).call(this);

//# sourceMappingURL=sub.js.map
